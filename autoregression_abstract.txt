1. 摘要
任务类型：自监督学习任务
模型类型: 序列到序列模型。
核心架构: 基于 LSTM 的编码器-解码器架构。
训练任务: 自回归时间序列预测。
模型被训练来预测未来的传感器数据序列，目的是让Encoder学习到时间序列数据中丰富的上下文特征表示。这个训练好的Encoder随后可以作为特征提取器，用于Cloud的分类任务。
数据源: MobiFall数据集，包含了加速度计 (acc)、陀螺仪 (gyro) 和方向 (ori) 传感器的数据。

2. 模型输入 (Model Input)
模型的输入是一个固定长度的时间序列片段
内容: 过去 4 秒的传感器数据。
维度: (Batch_Size, 200, 11)
	200: 输入序列长度 (INPUT_SEQ_LEN)。这是由 50 Hz 采样率 * 4 秒（200个时间点）计算得来。
	11: 特征维度 (INPUT_DIM)。
11个具体特征:
	acc_x (X轴加速度)
	acc_y (Y轴加速度)
	acc_z (Z轴加速度)
	acc_smv (加速度信号幅值向量)
	gyro_x (X轴陀螺仪)
	gyro_y (Y轴陀螺仪)
	gyro_z (Z轴陀螺仪)
	gyro_smv (陀螺仪信号幅值向量)
	ori_azimuth (方位角)
	ori_pitch (俯仰角)
	ori_roll (翻滚角)

预处理: 输入数据经过了 StandardScaler 的标准化处理，该Scaler仅使用训练集数据进行拟合。

3. 模型输出
模型的输出 (Output) 是对紧接着输入序列的未来时间序列的预测
内容: 未来 2 秒的传感器数据预测值。
维度: (Batch_Size, 100, 11)
100: 目标序列长度 (TARGET_SEQ_LEN)。这是由 50 Hz 采样率 * 2 秒（100个时间点）计算得来。
11: 特征维度 (OUTPUT_DIM)，与输入维度相同。
Ground Truth (真实标签): 在训练时，模型的输出（预测值）会与真实的未来100个时间点的数据（即 target 序列）进行比较，以计算损失。

4. 训练过程
数据预处理
重采样: 原始 MobiFall 数据被重采样至 50 Hz 的统一频率。
插值: 使用线性插值填充缺失数据。
特征工程: 计算了加速度计和陀螺仪的信号幅值向量 (SMV)。
对齐: 将 acc、gyro、ori 三种传感器数据按时间戳严格对齐。
序列切片: 使用6秒（300个点）的滑动窗口，以2秒（100个点）的步长，从试验数据中提取序列。
输入/目标分割: 每个300点的序列被分割为前200点（输入）和后100点（目标）。
标准化: 使用 StandardScaler 对所有数据进行Z-score标准化。

模型架构超参数
INPUT_DIM: 11
OUTPUT_DIM: 11
HIDDEN_DIM (LSTM隐藏层维度): 64
N_LAYERS (LSTM层数): 2
DROPOUT: 0.1

训练超参数
数据集划分: 80% 训练集, 20% 验证集。
Batch Size: 128
Epochs: 100
Optimizer: Adam
Learning Rate: 0.001
Loss Function: nn.MSELoss。
评估指标: 除了MSE，还监控了 nn.L1Loss (MAE) 作为验证指标。

训练策略
Teacher Forcing (强制教学): 在训练阶段，以0.5的概率使用。即在解码的每一步，有50%的概率使用真实的 target 数据作为下一步的输入，这有助于加速模型收敛。
Autoregression (自回归): 在验证阶段 (teacher_forcing_ratio=0)。解码器在第一步之后，完全依赖自己上一步的预测值作为下一步的输入。这更符合真实的预测（推理）场景。